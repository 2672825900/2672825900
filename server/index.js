/* eslint-disable no-console */

import express from 'express';
import compression from 'compression';
import { resolve as pathResolve } from 'path';
import appRootDir from 'app-root-dir';
import session from 'express-session';
import * as http from 'http';
import * as cookie from 'cookie-signature';
import * as qs from 'query-string';
import * as _ from 'lodash';
import reactApplication from './middleware/reactApplication';
import security from './middleware/security';
import clientBundle from './middleware/clientBundle';
import serviceWorker from './middleware/serviceWorker';
import offlinePage from './middleware/offlinePage';
import errorHandlers from './middleware/errorHandlers';
import config from '../config';
import torrentStore from './middleware/helpers/torrentStore';
import socketIo from './middleware/helpers/socketIo';
import { download, list, deleteTorr, searchTorrent } from './middleware/torrent';

const socketToSessionMapping = {};

// Create our express based server.
const app = express();

// Don't expose any software information to potential hackers.
app.disable('x-powered-by');

// Security middlewares.
app.use(...security);

// Gzip compress the responses.
app.use(compression());

const sessionMiddleware = session({
  secret: 'secret',
  name: 'session_name',
  resave: false,
  saveUninitialized: true,
  cookie: {
    httpOnly: false,
  },
});

app.use(sessionMiddleware);

// Register our service worker generated by our webpack config.
// We do not want the service worker registered for development builds, and
// additionally only want it registered if the config allows.
if (!process.env.BUILD_FLAG_IS_DEV && config('serviceWorker.enabled')) {
  app.get(`/${config('serviceWorker.fileName')}`, serviceWorker);
  app.get(
    `${config('bundles.client.webPath')}${config('serviceWorker.offlinePageFileName')}`,
    offlinePage,
  );
}

app.get('/api/list', list);
app.get('/api/download/:torrentId/:fileId/:fileName', download);
app.get('/api/delete/:torrentId', deleteTorr);
app.get('/api/search/:searchTerm', searchTorrent);

// Configure serving of our client bundle.
app.use(config('bundles.client.webPath'), clientBundle);

// Configure static serving of our "public" root http path static files.
// Note: these will be served off the root (i.e. '/') of our application.
app.use(express.static(pathResolve(appRootDir.get(), config('publicAssetsPath'))));

// The React application middleware.
app.get('*', reactApplication);

// Error Handler middlewares.
app.use(...errorHandlers);

const server = http.createServer(app);

const sio = socketIo.create(server);

sio.set('authorization', (data, accept) => {
  // check if there's a cookie header
  if (data.headers.cookie) {
    const sessionName = qs.parse(data.url.split('?')[1]).session_name;

    // if there is, parse the cookie
// eslint-disable-next-line no-param-reassign
    data.headers.sessionID = cookie.unsign(sessionName.slice(2), 'secret'); // hacky from source code
  } else {
    // if there isn't, turn down the connection with a message
    // and leave the function.
    return accept('No cookie transmitted.', false);
  }
  // accept the incoming connection
  return accept(null, true);
});

sio.sockets.on('connection', (socket) => {
  const sessionID = socket.handshake.headers.sessionID;

  const mapping = socketToSessionMapping[sessionID];

  if (mapping) {
    socketToSessionMapping[sessionID].push(socket.id);
  } else {
    socketToSessionMapping[sessionID] = [socket.id];
  }

  socket.on('disconnect', () => {
    if (socketToSessionMapping[sessionID]) {
      _.remove(socketToSessionMapping[sessionID], n => n === socket.id);

      if (socketToSessionMapping[sessionID].length === 0) {
        // destroy everything related to that session
        torrentStore.destroyClient(sessionID);
        delete socketToSessionMapping[sessionID];
      }
    }
  });
});

server.listen(config('port'), config('host'), () =>
  console.log(`Server listening on port ${config('port')}`),
);

// We export the listener as it will be handy for our development hot reloader,
// or for exposing a general extension layer for application customisations.
export default server;
